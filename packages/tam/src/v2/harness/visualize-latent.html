<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TAM v2 Latent Space Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    h1 {
      margin-top: 0;
      color: #333;
    }

    .file-input {
      margin-bottom: 20px;
      padding: 10px;
      background: #f8f8f8;
      border-radius: 4px;
    }

    input[type="file"] {
      padding: 8px;
    }

    .controls {
      margin: 20px 0;
      padding: 15px;
      background: #f8f8f8;
      border-radius: 4px;
    }

    .chart-container {
      display: flex;
      gap: 30px;
      margin-top: 20px;
    }

    .chart {
      flex: 1;
    }

    .port-circle {
      stroke: #fff;
      stroke-width: 2;
    }

    .port-label {
      font-size: 10px;
      font-weight: bold;
      fill: #333;
      pointer-events: none;
    }

    .state-marker {
      fill: #666;
      opacity: 0.3;
    }

    .axis-label {
      font-size: 12px;
      font-weight: 600;
    }

    .heatmap-cell {
      stroke: #fff;
      stroke-width: 1;
    }

    .legend {
      font-size: 12px;
    }

    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .slider {
      width: 100%;
      margin: 10px 0;
    }

    .checkpoint-info {
      font-weight: bold;
      color: #3498db;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>TAM v2 Latent Space Visualization</h1>

    <div class="file-input">
      <label for="jsonl-file">Load latent.jsonl:</label>
      <input type="file" id="jsonl-file" accept=".jsonl">
    </div>

    <div class="controls" id="controls" style="display: none;">
      <div>
        <label for="checkpoint-slider">Checkpoint: <span id="checkpoint-label" class="checkpoint-info"></span></label>
        <input type="range" id="checkpoint-slider" class="slider" min="0" max="0" value="0">
      </div>
    </div>

    <div class="chart-container">
      <div class="chart" id="embedding-chart"></div>
      <div class="chart" id="heatmap-chart"></div>
    </div>
    <div id="tooltip" class="tooltip"></div>
  </div>

  <script>
    let checkpoints = [];
    let representativeStates = [];

    // Handle file upload
    document.getElementById('jsonl-file').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        const text = event.target.result;
        checkpoints = text.trim().split('\n').map(line => JSON.parse(line));

        // Extract representative states from first checkpoint
        if (checkpoints.length > 0) {
          const firstCheckpoint = checkpoints[0];
          if (firstCheckpoint.ports.length > 0) {
            representativeStates = firstCheckpoint.ports[0].commitments.map(c => c.stateIdx);
          }
        }

        document.getElementById('controls').style.display = 'block';
        const slider = document.getElementById('checkpoint-slider');
        slider.max = checkpoints.length - 1;
        slider.value = checkpoints.length - 1;

        visualize(checkpoints.length - 1);
      };
      reader.readAsText(file);
    });

    // Slider control
    document.getElementById('checkpoint-slider').addEventListener('input', function(e) {
      visualize(parseInt(e.target.value));
    });

    function visualize(checkpointIdx) {
      const checkpoint = checkpoints[checkpointIdx];
      document.getElementById('checkpoint-label').textContent =
        `Sample ${checkpoint.sample} (${checkpoint.ports.length} ports)`;

      // Clear previous charts
      d3.select('#embedding-chart').html('');
      d3.select('#heatmap-chart').html('');

      visualizeEmbeddings(checkpoint);
      visualizeHeatmap(checkpoint);
    }

    function visualizeEmbeddings(checkpoint) {
      const margin = { top: 40, right: 20, bottom: 60, left: 60 };
      const width = 600 - margin.left - margin.right;
      const height = 500 - margin.top - margin.bottom;

      const svg = d3.select('#embedding-chart')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      // Title
      svg.append('text')
        .attr('x', width / 2)
        .attr('y', -15)
        .attr('text-anchor', 'middle')
        .style('font-size', '14px')
        .style('font-weight', 'bold')
        .text('Port Embeddings with Cone Ranges (Polysemanticity)');

      // Find extent of embeddings
      const allEmbeddings = checkpoint.ports.map(p => p.embedding);
      const xExtent = d3.extent(allEmbeddings, d => d[0]);
      const yExtent = d3.extent(allEmbeddings, d => d[1]);

      const xScale = d3.scaleLinear()
        .domain([xExtent[0] - 0.5, xExtent[1] + 0.5])
        .range([0, width]);

      const yScale = d3.scaleLinear()
        .domain([yExtent[0] - 0.5, yExtent[1] + 0.5])
        .range([height, 0]);

      // Color scale for ports
      const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

      // Axes
      svg.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(xScale))
        .append('text')
        .attr('class', 'axis-label')
        .attr('x', width / 2)
        .attr('y', 40)
        .attr('fill', 'black')
        .text('Dimension 1 (e.g., position)');

      svg.append('g')
        .call(d3.axisLeft(yScale))
        .append('text')
        .attr('class', 'axis-label')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height / 2)
        .attr('y', -45)
        .attr('fill', 'black')
        .attr('text-anchor', 'middle')
        .text('Dimension 2 (e.g., velocity)');

      const tooltip = d3.select('#tooltip');

      // Draw ports with varying sizes per state
      checkpoint.ports.forEach(port => {
        const minConc = d3.min(port.commitments, c => c.concentration);
        const maxConc = d3.max(port.commitments, c => c.concentration);

        // Draw min concentration circle (widest cone - faint)
        const maxRadius = 300 / minConc; // Inverse: lower concentration = wider cone
        svg.append('circle')
          .attr('class', 'port-circle')
          .attr('cx', xScale(port.embedding[0]))
          .attr('cy', yScale(port.embedding[1]))
          .attr('r', Math.min(maxRadius, 50))
          .attr('fill', colorScale(port.portIdx))
          .attr('opacity', 0.1)
          .attr('stroke', 'none');

        // Draw max concentration circle (narrowest cone - bold)
        const minRadius = 300 / maxConc; // Inverse: higher concentration = narrower cone
        svg.append('circle')
          .attr('class', 'port-circle')
          .attr('cx', xScale(port.embedding[0]))
          .attr('cy', yScale(port.embedding[1]))
          .attr('r', Math.min(minRadius, 50))
          .attr('fill', colorScale(port.portIdx))
          .attr('opacity', 0.6)
          .on('mouseover', function(event) {
            tooltip
              .style('opacity', 1)
              .style('left', (event.pageX + 10) + 'px')
              .style('top', (event.pageY - 10) + 'px')
              .html(`
                <strong>Port ${port.portIdx}</strong><br/>
                Embedding: [${port.embedding.map(v => v.toFixed(2)).join(', ')}]<br/>
                Max concentration (narrowest): ${maxConc.toFixed(3)}<br/>
                Min concentration (widest): ${minConc.toFixed(3)}<br/>
                Range shows polysemanticity
              `);
          })
          .on('mouseout', () => tooltip.style('opacity', 0));

        svg.append('text')
          .attr('class', 'port-label')
          .attr('x', xScale(port.embedding[0]))
          .attr('y', yScale(port.embedding[1]))
          .attr('dy', 4)
          .attr('text-anchor', 'middle')
          .text(port.portIdx);
      });
    }

    function visualizeHeatmap(checkpoint) {
      const margin = { top: 40, right: 20, bottom: 60, left: 60 };
      const width = 600 - margin.left - margin.right;
      const height = 500 - margin.top - margin.bottom;

      const svg = d3.select('#heatmap-chart')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      // Title
      svg.append('text')
        .attr('x', width / 2)
        .attr('y', -15)
        .attr('text-anchor', 'middle')
        .style('font-size', '14px')
        .style('font-weight', 'bold')
        .text('Port Commitment Distances at Test States');

      const numPorts = checkpoint.ports.length;
      const numStates = representativeStates.length;

      const cellWidth = width / numStates;
      const cellHeight = height / numPorts;

      // Extract concentrations for color scale
      const allConcentrations = checkpoint.ports.flatMap(p => p.commitments.map(c => c.concentration));
      // Higher concentration = narrower cone = higher commitment = greener
      const colorScale = d3.scaleSequential(d3.interpolateYlGn)
        .domain([0, d3.max(allConcentrations)]);

      const tooltip = d3.select('#tooltip');

      // Draw heatmap
      checkpoint.ports.forEach((port, portIdx) => {
        port.commitments.forEach(commit => {
          svg.append('rect')
            .attr('class', 'heatmap-cell')
            .attr('x', commit.stateIdx * cellWidth)
            .attr('y', portIdx * cellHeight)
            .attr('width', cellWidth)
            .attr('height', cellHeight)
            .attr('fill', colorScale(commit.concentration))
            .attr('stroke-width', commit.selected ? 3 : 1)
            .attr('stroke', commit.selected ? '#000' : '#fff')
            .on('mouseover', function(event) {
              tooltip
                .style('opacity', 1)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .html(`
                  <strong>Port ${port.portIdx} @ State ${commit.stateIdx}</strong><br/>
                  Concentration: ${commit.concentration.toFixed(3)}<br/>
                  Cone: ${(1/commit.concentration).toFixed(3)} (radius)<br/>
                  Selected: ${commit.selected ? 'Yes' : 'No'}
                `);
            })
            .on('mouseout', () => tooltip.style('opacity', 0));
        });
      });

      // X axis (states)
      svg.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(d3.scaleLinear().domain([0, numStates]).range([0, width])).ticks(numStates))
        .append('text')
        .attr('class', 'axis-label')
        .attr('x', width / 2)
        .attr('y', 40)
        .attr('fill', 'black')
        .text('Test State Index');

      // Y axis (ports)
      svg.append('g')
        .call(d3.axisLeft(d3.scaleLinear().domain([0, numPorts]).range([0, height])).ticks(numPorts))
        .append('text')
        .attr('class', 'axis-label')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height / 2)
        .attr('y', -45)
        .attr('fill', 'black')
        .attr('text-anchor', 'middle')
        .text('Port Index');

      // Color legend
      const legendWidth = 200;
      const legendHeight = 20;
      const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', `translate(${width - legendWidth}, ${height + 35})`);

      const legendScale = d3.scaleLinear()
        .domain([0, d3.max(allConcentrations)])
        .range([0, legendWidth]);

      const legendAxis = d3.axisBottom(legendScale).ticks(5);

      // Gradient
      const defs = svg.append('defs');
      const gradient = defs.append('linearGradient')
        .attr('id', 'legend-gradient');

      gradient.selectAll('stop')
        .data(d3.range(0, 1.1, 0.1))
        .enter().append('stop')
        .attr('offset', d => `${d * 100}%`)
        .attr('stop-color', d => colorScale(d * d3.max(allConcentrations)));

      legend.append('rect')
        .attr('width', legendWidth)
        .attr('height', legendHeight)
        .style('fill', 'url(#legend-gradient)');

      legend.append('g')
        .attr('transform', `translate(0,${legendHeight})`)
        .call(legendAxis);

      legend.append('text')
        .attr('x', legendWidth / 2)
        .attr('y', -5)
        .attr('text-anchor', 'middle')
        .style('font-size', '11px')
        .text('Concentration (higher = narrower cone)');
    }
  </script>
</body>
</html>
